
CREATE OR REPLACE FUNCTION crear_incidencia_completa(
    p_id_usuario uuid,
    p_numero_reportado varchar,
    p_categoria_reporte varchar,
    p_descripcion text,
    p_medio_contacto varchar,
    p_genero varchar DEFAULT NULL,
    p_supuesto_nombre varchar DEFAULT NULL,
    p_supuesto_trabajo varchar DEFAULT NULL,
    p_es_visible boolean DEFAULT true,
    p_estatus varchar DEFAULT 'pendiente',
    p_tipo_destino text DEFAULT NULL,    -- 'tarjeta' o 'ubicacion'
    p_numero_tarjeta varchar DEFAULT NULL,
    p_direccion varchar DEFAULT NULL
)
RETURNS json
LANGUAGE plpgsql
AS $$
DECLARE
    v_id_numero uuid;
    v_id_reporte uuid;
BEGIN
    -- 1. Gestionar la tabla 'reportados' (UPSERT)
    -- Intenta insertar el número. Si existe (conflicto), actualiza el contador 'vecesReportado'
    -- y devuelve el ID en ambos casos.
    INSERT INTO reportados (numeroReportado, vecesReportado)
    VALUES (p_numero_reportado, 1)
    ON CONFLICT (numeroReportado) 
    DO UPDATE SET vecesReportado = reportados.vecesReportado + 1
    RETURNING idNumero INTO v_id_numero;

    -- 2. Insertar en la tabla 'reportes'
    INSERT INTO reportes (
        idUsuario, 
        idNumero, 
        categoriaReporte, 
        descripcion, 
        medioContacto, 
        genero, 
        supuestoNombre, 
        supuestoTrabajo, 
        esVisible, 
        estatus
    )
    VALUES (
        p_id_usuario, 
        v_id_numero, 
        p_categoria_reporte, 
        p_descripcion, 
        p_medio_contacto, 
        p_genero, 
        p_supuesto_nombre, 
        p_supuesto_trabajo, 
        p_es_visible, 
        p_estatus
    )
    RETURNING idReporte INTO v_id_reporte;

    -- 3. Insertar en 'destino' si corresponde
    IF p_tipo_destino IS NOT NULL AND p_tipo_destino IN ('tarjeta', 'ubicacion') THEN
        INSERT INTO destino (
            tipoEnum, 
            numeroTarjeta, 
            direccion, 
            idReporte
        )
        VALUES (
            p_tipo_destino, 
            p_numero_tarjeta, 
            p_direccion, 
            v_id_reporte
        );
    END IF;

    -- 4. Retornar respuesta en formato JSON (igual que tu API)
    RETURN json_build_object(
        'mensaje', 'Incidencia creada correctamente',
        'idReporte', v_id_reporte
    );

EXCEPTION WHEN OTHERS THEN
    -- Captura de errores y rollback automático
    RAISE EXCEPTION 'Error al crear la incidencia: %', SQLERRM;
END;
$$;

-----------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION obtener_usuario_por_correo_y_telefono_opt(
    p_correo TEXT,
    p_telefono VARCHAR
)
RETURNS JSON
LANGUAGE plpgsql
AS $$
DECLARE
    v_resultado RECORD;
BEGIN
    -- Hacemos una sola consulta uniendo ambas tablas
    SELECT u.idUsuario, u.nombre
    INTO v_resultado
    FROM usuarios u
    INNER JOIN correos c ON u.idUsuario = c.idUsuario
    WHERE c.correo = p_correo 
      AND u.numeroTelefono = p_telefono
    LIMIT 1;

    -- Si no encontró nada (v_resultado es NULL), devolvemos error
    IF v_resultado IS NULL THEN
        RETURN json_build_object(
            'error', true,
            'mensaje', 'No se encontró un usuario con ese correo y teléfono',
            'data', NULL
        );
    END IF;

    -- Si lo encontró, devolvemos éxito
    RETURN json_build_object(
        'error', false,
        'mensaje', 'Usuario encontrado correctamente',
        'data', json_build_object(
            'idusuario', v_resultado.idUsuario,
            'nombre', v_resultado.nombre
        )
    );

EXCEPTION WHEN OTHERS THEN
    RETURN json_build_object(
        'error', true,
        'mensaje', 'Error interno al consultar usuario',
        'detalle', SQLERRM
    );
END;
$$;